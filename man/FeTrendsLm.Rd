% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FeTrendsLm.R
\name{FeTrendsLm}
\alias{FeTrendsLm}
\title{FeTrendsLm}
\value{
Object of \code{R6Class} with methods and data related to estiamtion.
}
\description{
Large Data Estimation linear fixed effect models with trends
}
\details{
The FeTrendsLm class provides an R6 class to estimate linear models
fixed effects and/or trends with large data. Consider the following
model from Angrist and Pischke "Mastering Metrics" (2015), equation
(5.6) that is going to estimate a difference-in-differences model
that measures the impact of legalized drinking on deaths (see
examples below for implentation):

\eqn{Y_{st} = \alpha + \gamma_{rDD} \textit{LEGAL}_{st} + \gamma_i + \gamma_t + \gamma_{st} + \varepsilon_{it}}

\eqn{\gamma_i} and \eqn{\gamma_t} are state and time fixed
effects. \eqn{\gamma_{st}} is a state time trend (\eqn{\gamma_i \times
t}). The state and time fixed effects along with the state time
trends, yield a large number of parameters to be estimated.

See also equation (5.2.7) from Angrist and Pischke (2009) employs
an individual level panel, state fixed effects, and state time trends:

\eqn{Y_{ist} = \gamma_{0s} + \gamma_{1st} + \lambda_t + \beta D_{st} + X^\prime_{ist} \delta + \varepsilon_{ist}}
}
\section{FeTrendsLm$new() Method}{

The \code{FeTrendsLm$new()} method initializes FeTrendsLm class and partial out variables in
preperation for estimation. \code{$new()} takes the following parameters
(see examples below):

\strong{Usage}:

\code{out <- FeTrendsLm$new(DT, .f, main.reg.vars = NULL, cluster.vars = NULL, chunk.size = 100, keycolsv = NULL, weight.var = NULL)}

\strong{Parameters}:
\describe{
\item{\code{DT}}{A \code{data.table} with the data. \code{DT} should have no
\code{NA} values for variables to be used in estimation.
Note that the \code{FeTrendsLm$new()} function
\strong{updates DT by reference}. So, \code{DT} will be different
in the global environment after running \code{FeTrendsLm$new()}.
Setting \code{data.table} \code{keys} based on the dimension of
the fixed effects to be partialed out, will speed up
estiamtion. See the data.table documenation for more.}
\item{\code{.f}}{A right-hand-side formula with variables to be
partialed out. Fixed effects must be character columns.
Character vectors can be interacted with a numeric column
(e.g. a time trend)}
\item{\code{main.reg.vars}}{Optional character vector of the variables to be
used in the final regression. If \code{NULL}, \code{main.reg.vars}
with defualt to all variables that are not in \code{~.f}}
\item{\code{cluster.vars}}{Optional character vector of variables to be used
in clustering standard errors. If \code{NULL}, robust \code{HC1}
standard errors will be used. If not \code{NULL} clustered standard
errors will be computed using the using the \code{HC1} correction}
\item{\code{chunk.size}}{Integer of length 1. The size of the the chunks with which to
partial out columns. The defualt is \code{100}, meaning that columns
will be partialed out in batches of 100 at a time. Larger values
may be faster, but will use more memory.}
\item{\code{keycolsv}}{A character vector of the columns which will be used as \code{data.table}
keys. If making multiple calls to the same dataset, \code{DT}, it will
faster to set the keys beforehand.}
\item{\code{weight.var}}{A string with the variable to weight. \strong{NOT CURRENTLY IMPLEMENTED}}
}

\strong{Return Value}:
An object of class \code{FeTrendsLm}
}

\section{$fetrendslm()}{

The \code{$fetrendslm()} method estimates a regression after partialling out variables

\strong{Usage}:

See examples below

\strong{Parameters}:
\describe{
\item{\code{y.var}}{A string with the dependent, left-hand-side variable}
\item{\code{x.vars}}{A character vector with the independent, right-hand-side variables}
}

\strong{Return Value}:
A list with the following items
\describe{
\item{coef}{A numeric vector with the regression coefficients}
\item{se}{A numeric vector with the regression standard errors}
\item{N}{The number of observations used in the regression}
\item{DT.tidy}{A \code{data.table} with parameter estimation output that
matches \code{broom::tidy(.)}}
\item{lm.mod}{A small linear model, that can be used with stargazer.
Note that the standard errors will have to be applied manually
to stargazer}
}
}

\examples{

## From Angrist and Pischke (2015) eqn. 5.6
## Difference-in-differences.

library(lfe) ##To compare results to lfe:felm()
library(stargazer) ##for pretty printing of output
data(deaths)

##Dataset for felm()
DT.felm <- copy(deaths)
DT.felm <- DT.felm[, year.char := as.factor(year.char)]
DT.felm <- DT.felm[, state.char := as.factor(state.char)]

##so the original deaths dataset isn't updated by reference
DT1 <- copy(deaths)

## -- State and time fixed effects with clustering --##

est1 <- FeTrendsLm$new(DT1, .f = ~ state.char + year.char,
                       cluster.vars = "state.char")
mod1 <- est1$fetrendslm(y.var = "mrate", x.vars = c("legal"))

##The parameters
print(mod1$coef)
#'The standard errors
print(mod1$se)
##Print the number of observations
print(mod1$N)
##print the data.table with the same outpub as broom::tidy()
print(mod1$DT.tidy)

##compare to lfe::felm() and print to stargazer
mod1.felm <- felm(mrate ~ legal | state.char + year.char | 0 | state.char,
                  DT.felm)

##Stargazer comparison
##Notice how the number of obersvations is wrong
##for mod1$lm.mod -- you must fix that by hand
stargazer(mod1$lm.mod, mod1.felm, type = "text",
          se = list(mod1$se, mod1.felm$cse),
          keep.stat = "n")

## -- State FE, time FE, State time tremds; with clustering --##

DT2 <- copy(deaths)

est2 <- FeTrendsLm$new(DT2, .f = ~ state.char + year.char + state.char:year,
                       cluster.vars = "state.char")
mod2 <- est2$fetrendslm(y.var = "mrate", x.vars = c("legal"))

##compare to lfe::felm() and print to stargazer
mod2.felm <- felm(mrate ~ legal | state.char + year.char + state.char:year | 0 | state.char,
                  DT.felm)

##Stargazer comparison
##Notice how the number of obersvations is wrong
##for mod1$lm.mod -- you must fix that by hand
stargazer(mod2$lm.mod, mod2.felm, type = "text",
          se = list(mod2$se, mod2.felm$cse),
          keep.stat = "n")
}
